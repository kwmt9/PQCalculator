@using System.Text.Json
@inject HttpClient Http
@page "/"
<PageTitle>パワクエコーチ計算機(仮)</PageTitle>

<div class="container d-flex flex-column align-items-center width-clamp">
    <h1 class="mb-1">パワクエコーチ計算機(仮)</h1>
    <div class="mb-3">
        <Collapse Title="説明">
            <ol>
                <li>契約書キャラを入力する</li>
                <li>能力を調整する</li>
                <li>コーチ人数を入力</li>
                <li>計算開始を押す</li>
                <li>持ってないキャラはバツを押す</li>
            </ol>
        </Collapse>
    </div>
    @if (EventUnits != null) {
        <div class="mb-3">
            <AutoCompleteInput @ref="AutoCompleteInput" StringList="Suggest" Placeholder="契約書キャラ選択" TextChanged="@((s) => GetUnitStates())"></AutoCompleteInput>
        </div>
        <h3>契約書能力設定</h3>
        if (PQPlayerUnit != null) {
            <PlayerPositionComponent Position="PQPlayerUnit.Position"></PlayerPositionComponent>
            <AbilityListComponent Abilitys="PQPlayerUnit.Abilities"></AbilityListComponent>
        }
        <div id="calculationForm">
            <div>
                <div class="input-group mb-1">
                    <span class="input-group-text fw-bold">ミート</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.Meet)" @oninput="((e) => InputStatus.Meet = int.Parse(e.Value.ToString()))">
                </div>
                <div class="input-group mb-1">
                    <span class="input-group-text fw-bold">パワー</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.Power)" @oninput="((e) => InputStatus.Power = int.Parse(e.Value.ToString()))">
                </div>
                <div class="input-group mb-1">
                    <span class="input-group-text fw-bold">走力　</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.RunPower)" @oninput="((e) => InputStatus.RunPower = int.Parse(e.Value.ToString()))">
                </div>
                <div class="input-group mb-1">
                    <span class="input-group-text fw-bold">肩力　</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.ShoulderPower)" @oninput="((e) => InputStatus.ShoulderPower = int.Parse(e.Value.ToString()))">
                </div>
                <div class="input-group mb-1">
                    <span class="input-group-text fw-bold">守備力</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.Fielding)" @oninput="((e) => InputStatus.Fielding = int.Parse(e.Value.ToString()))">
                </div>
                <div class="input-group mb-2">
                    <span class="input-group-text fw-bold">捕球　</span>
                    <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputStatus.Catching)" @oninput="((e) => InputStatus.Catching = int.Parse(e.Value.ToString()))">
                </div>
                @if (PQPlayerUnit?.Position == 1) {
                    <div class="input-group mb-2">
                        <span class="input-group-text fw-bold">球速　</span>
                        <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputPitcherStatus.BallSpeed)" @oninput="((e) => InputPitcherStatus.BallSpeed = int.Parse(e.Value.ToString()))">
                    </div>
                    <div class="input-group mb-2">
                        <span class="input-group-text fw-bold">コン　</span>
                        <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputPitcherStatus.BallControl)" @oninput="((e) => InputPitcherStatus.BallControl = int.Parse(e.Value.ToString()))">
                    </div>
                    <div class="input-group mb-2">
                        <span class="input-group-text fw-bold">スタ　</span>
                        <input type="number" id="typeNumber" class="form-control fw-bold" min="1" max="100" value="@(InputPitcherStatus.Stamina)" @oninput="((e) => InputPitcherStatus.Stamina = int.Parse(e.Value.ToString()))">
                    </div>
                }

            </div>
            <div class="input-group mb-2">
                <span class="input-group-text fw-bold">コーチ人数　</span>
                <input type="number" id="typeNumber" class="form-control fw-bold" min="0" max="4" @bind="CoarchCount">
            </div>
        </div>
        <div class="mb-2">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="check1" @onchange='(e) => isSubPosition = (bool)e.Value'>
                <label class="form-check-label" for="check1">
                    サブポジ運用
                </label>
            </div>
        </div>
        <div class="mb-2">
            @if (false) {
                <div class="form-check">
                    <input class="form-check-input" type="radio" name="flexRadioDefault" id="flexRadioDefault1" @onchange='(e) => OnRadioChange("1")'>
                    <label class="form-check-label" for="flexRadioDefault1">
                        能力101優先上げ
                    </label>
                </div>
            <div class="form-check">
                    <input class="form-check-input" type="radio" name="flexRadioDefault" id="flexRadioDefault3" @onchange='(e) => OnRadioChange("3")' checked>
                <label class="form-check-label" for="flexRadioDefault3">
                    バランス上げ
                </label>
            </div>
            }
        </div>
        <button @onclick="CaluculateCoach" class="btn btn-primary mb-5">計算開始</button>
    }
</div>
@if (decks != null)
{
    <div class="d-flex justify-content-center flex-column align-items-center">
        <h3>計算結果</h3>
        @if (PQPlayerUnit?.Position == 1) {
            <StatusComponent FielderStatus="DeckLimit" PitcherStatus="DeckPitcherLimit"></StatusComponent>
        }else {
            <StatusComponent FielderStatus="DeckLimit"></StatusComponent>
        }


    </div>
    <div class="d-flex flex-wrap justify-content-start justify-content-xl-center">
        
        @for (int i = 0; i < decks.GroupBy(x => x.deckNumber).Count(); i++)
        {
            var deck = decks.GroupBy(x => x.deckNumber).Where(x => x.Key == i);
            <div class="d-inline-flex flex-column col-12 col-lg-6 col-xl-3 align-items-baseline border rounded">
                <h3>デッキ @(
            i + 1
            )</h3>
                <div class="mb-3">
                    @foreach (var units in deck.First()) {
                        var unit = units.unit;
                        <div style="display: flex;">
                            <div>@unit.Name</div>
                            <!--
                                <div>@($"{unit.Limit.Meet} {unit.Limit.Power} {unit.Limit.RunPower} {unit.Limit.ShoulderPower} {unit.Limit.Fielding} {unit.Limit.Catching} {unit.Limit.BallControl} {unit.Limit.Stamina}")</div>
                            -->
                            <button type="button" class="btn-close" aria-label="Close" @onclick="() => AddNotOwnedUnit(unit.Id)"></button>
                        </div>
                    }
                </div>
                <div class="mb-3">
                    @if (deckAbilites != null) {
                        @foreach (var ab in deckAbilites[i]) {
                            <div class="mb-2">
                                <AbilityComponent Ability="@ab"></AbilityComponent>
                                <span class="fw-bold">@ab.SateiMain</span>
                            </div>
                        }
                    }
                </div>
            </div>
        }
    </div>
}

@if (notOwnedUnits.Count > 0) {
    <Liner></Liner>
    <h3>持ってないキャラ</h3>
    @foreach (var id in notOwnedUnits) {
        <div style="display: flex;">
            <div>@(
           EventUnits.FirstOrDefault(x => x.Id == id).Name
           )</div>
            <button type="button" class="btn-close" aria-label="Close" @onclick="() => RemoveNotOwnedUnit(id)"></button>
        </div>
    }
    <button @onclick="RemoveNotOwnedUnitAll" class="btn btn-primary mb-3">リセット</button>
}

@code {
    [Inject]
    private IJSRuntime JSRuntime { get; set; }

    public List<string>? Suggest { get; set; }
    public List<PQEventUnit>? RemoveAddedUnits;
    public List<PQEventUnit>? EventUnits;

    AutoCompleteInput? AutoCompleteInput;
    PQPlayerUnit? PQPlayerUnit;
    List<PQAbility>? PQAbilitys;

    List<PQPlayerUnit>? PQPlayerUnits;

    bool isSubPosition = false;

    HashSet<int> notOwnedUnits = new();
    private void AddNotOwnedUnit(int id) {
        notOwnedUnits.Add(id);
        SetLastDeck();
        CaluculateCoach();
    }
    private void RemoveNotOwnedUnit(int id) {
        notOwnedUnits.Remove(id);
        SetLastDeck();
        CaluculateCoach();
    }
    private void RemoveNotOwnedUnitAll() {
        notOwnedUnits = new();
        SetLastDeck();
        CaluculateCoach();
    }
    //ローカルストレージから取得
    public async Task LoadLastDeck() {
        try {
            var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "notOwnUnit");

            if (!string.IsNullOrEmpty(json)) {
                notOwnedUnits = JsonSerializer.Deserialize<int[]>(json)?.ToHashSet() ?? new HashSet<int>();
            }
            else {
                notOwnedUnits = new HashSet<int>();
            }
        }
        catch (Exception ex) {
            // エラーハンドリング
            Console.WriteLine($"Error loading data from localStorage: {ex.Message}");
            notOwnedUnits = new HashSet<int>();  // 失敗した場合もデフォルト値を設定
        }
    }

    //ローカルストレージに保存
    private async Task SetLastDeck() {
        await JSRuntime.InvokeVoidAsync(
            "localStorage.setItem",
            "notOwnUnit",
            JsonSerializer.Serialize(
                notOwnedUnits.ToArray()
        )
        );
    }
    const int DECK_MAX_COUNT = 9;
    List<Deck>? decks;
    List<List<PQAbility>>? deckAbilites = new();

    UnitFielderStatus InputStatus = new(0, 0, 50, 50, 50, 50, 50, 50);
    UnitFielderStatus DeckLimit = new(0, 0, 0, 0, 0, 0, 0, 0);

    UnitPitcherStatus InputPitcherStatus = new(0, 120, 50, 50);
    UnitPitcherStatus DeckPitcherLimit = new(0, 0, 0, 0);

    int CoarchCount = 3;

    int CalucMode = 1;
    private void OnRadioChange(string newValue) {
        int ValueInt = int.Parse(newValue);
        CalucMode = ValueInt;
    }

    protected override async Task OnInitializedAsync() {
        EventUnits = await Http.GetFromJsonAsync<List<PQEventUnit>>("json/eventUnit.json");
        PQPlayerUnits = await Http.GetFromJsonAsync<List<PQPlayerUnit>>($"json/playerUnit.json");
        PQAbilitys = await Http.GetFromJsonAsync<List<PQAbility>>($"json/satei.json");

        Suggest = PQPlayerUnits?.Where(x => x.Position != 0).OrderByDescending(x => x.Id).Select(u => u.Name).ToList();
        InputStatus = new(0, 0, 50, 50, 50, 50, 50, 50);
        InputPitcherStatus = new(0, 120, 50, 50);
        await LoadLastDeck();
    }

    public async Task GetUnitStates() {
        if (AutoCompleteInput?.InputValue == null) { return; }
        PQPlayerUnit = null;
        PQPlayerUnit = PQPlayerUnits?.FirstOrDefault(u => u.Name == AutoCompleteInput?.InputValue);
        Console.WriteLine(PQPlayerUnit.Name);
        if (PQPlayerUnit.Status != null) {
            InputStatus = new(0, 0,
                PQPlayerUnit.Status.Meet,
                PQPlayerUnit.Status.Power,
                PQPlayerUnit.Status.RunPower,
                PQPlayerUnit.Status.ShoulderPower,
                PQPlayerUnit.Status.Fielding,
                PQPlayerUnit.Status.Catching);
        }
        if (PQPlayerUnit.PitcherStatus != null) {
            InputPitcherStatus = new(0,
                PQPlayerUnit.PitcherStatus.BallSpeed,
                PQPlayerUnit.PitcherStatus.BallControl,
                PQPlayerUnit.PitcherStatus.Stamina);
        }
        StateHasChanged();
    }

    public async Task CaluculateCoach() {
        if (PQPlayerUnit == null) {
            return;
        }
        //とりあえず野手
        var canLearnAbilitys = PQAbilitys.Where(x => x.PlayerType == 1).ToList();
        //投手
        if (PQPlayerUnit.Position == 1) {
            canLearnAbilitys = PQAbilitys.Where(x => x.PlayerType == 2).ToList();
        }

        decks = new();
        deckAbilites = new();
        DeckLimit = new(0, 0, 0, 0, 0, 0, 0, 0);
        DeckPitcherLimit = new(0, 0, 0, 0);
        //所持している能力、同時取得できないを消す
        var pqAbilityes = await RemoveOwnedAbilities(canLearnAbilitys);
        pqAbilityes = RemoveNonConcurrentAbilities(pqAbilityes);

        //ポジションに応じて能力を消す
        pqAbilityes = await RemovePositionSpecificAbilities(pqAbilityes);
        pqAbilityes = await SumLowRankSatei(pqAbilityes);
        //もってないキャラを除外
        RemoveAddedUnits = await RemoveNotOwnEventUnit();
        pqAbilityes = pqAbilityes.OrderByDescending(s => s.SateiMain).ToList();
        //金徳入れる


        pqAbilityes = await AddGoldAbility(pqAbilityes);
        pqAbilityes = RemoveNonConcurrentAbilities(pqAbilityes);
        //威圧感
        pqAbilityes = await AddIatsukan(pqAbilityes);
        //能力上限を計算
        //if (PQPlayerUnit.Position != 1)
        //{
        //    switch (CalucMode)
        //    {
        //        case 1:
        //            await CaluculateLimitCoachMode2();
        //            break;
        //        case 2:
        //            await CaluculateLimitCoachMode2();
        //            break;
        //        case 3:
        //            await CaluculateLimitCoachMode2();
        //            break;
        //    }
        //}
        //else {
        //    await CaluculateLimitCoachMode2();
        //}
        await CaluculateLimitCoachMode2();

        //deckAbilitesの中の金特を除外
        pqAbilityes = RemoveDeckAbilities(pqAbilityes);
        //青特を高い順でで取る
        await AddBlueAbility(pqAbilityes);
    }
    public async Task<List<PQAbility>> AddGoldAbility(List<PQAbility> pqAbilityes) {
        //金徳入れる
        int skipCount = 0;
        int addCount = 0;
        for (int i = 0; i < CoarchCount; i++) {
            List<PQAbility> abilitys = new();
            addCount = 0;
            for (int k = 0; 2 > addCount; k++) {
                var ability = pqAbilityes.Skip(skipCount).First();
                skipCount++;
                RemoveAddedUnits = BalancedOrder(RemoveAddedUnits, 0).ToList();
                var unit = RemoveAddedUnits.FirstOrDefault(x => x.Abilities.Any(a => a.Id == ability.Id));
                if (unit == null) {
                    continue;
                }
                addCount++;
                decks.Add(new(unit, ability, i));
                abilitys.Add(ability);
            }
            deckAbilites.Add(abilitys);
        }
        return pqAbilityes;
    }

    public async Task<List<PQAbility>> AddIatsukan(List<PQAbility> pqAbilityes) {
        //威圧感を入れる
        //すでに入れたUnitは除外する
        var unitPool = RemoveAddedUnits.Where(u => !decks.Select(x => x.unit).Any(d => d.Id == u.Id));
        PQAbility iatukan = pqAbilityes.FirstOrDefault(s => s.Name.Contains("威圧感"));
        if (iatukan == null) return pqAbilityes;
        var havingIatukanUnit = unitPool?.FirstOrDefault(x => x.Abilities.Any(a => a.Id == iatukan.Id));
        if (havingIatukanUnit != null) {
            decks.Add(new(havingIatukanUnit, iatukan, 0));
            deckAbilites.First().Add(iatukan);
        }
        else {
            pqAbilityes = pqAbilityes.Where(x => !x.Name.Contains("威圧感")).ToList();
        }
        return pqAbilityes;
    }

    public async Task AddBlueAbility(List<PQAbility> pqAbilityes) {
        var OrderedBlueAbilities = pqAbilityes
        .Where(x => x.ColorType == 2)
        .GroupBy(a => a.GroupId)
        .Select(g => g.OrderByDescending(a => a.Rank).First())
        .OrderByDescending(x => x.SateiMain)
        .ToList();

        for (int i = 0; i < CoarchCount; i++) {
            for (int k = 0; deckAbilites[i].Count < 5; k++) {
                var abilitiys = deckAbilites[i];
                var blueAbility = OrderedBlueAbilities.First();
                abilitiys.Add(blueAbility);
                OrderedBlueAbilities = RemoveNonConcurrentAbility(OrderedBlueAbilities, blueAbility);
                OrderedBlueAbilities = RemoveDeckAbilities(OrderedBlueAbilities);
            }
        }
    }

    public List<PQAbility> RemoveDeckAbilities(List<PQAbility> pqAbilityes) {
        List<PQAbility> aaa = deckAbilites.SelectMany(x => x).ToList();
        pqAbilityes = pqAbilityes.Where(x => !aaa.Any(a => x.GroupId == a.GroupId)).ToList();

        return pqAbilityes;
    }
    //同時取得不可のアビリティを消す
    public List<PQAbility> RemoveNonConcurrentAbilities(List<PQAbility> pqAbilityes) {
        var ret = pqAbilityes;
        foreach (var ability in deckAbilites.SelectMany(x => x)) {
            ret = RemoveNonConcurrentAbility(ret, ability);
        }
        foreach (var ability in PQPlayerUnit.Abilities) {
            ret = RemoveNonConcurrentAbility(ret, ability);
        }
        return ret;
    }
    public List<PQAbility> RemoveNonConcurrentAbility(List<PQAbility> pqAbilityes, PQAbility ability) {
        var ret = pqAbilityes;
        // 同時取得不可のアビリティをマッピングするための辞書
        var nonConcurrentMap = new Dictionary<string, string>{
            { "パワーヒッター", "ラインドライブ" },
            { "アーチスト", "ラインドライブ" },
            { "ローボールヒッター", "ハイボールヒッター" },
            { "低球必打", "高球必打" },
            { "インコース◯", "アウトコース◯" },
            { "内角必打", "外角必打" },
            { "広角打法", "プルヒッター" },
            { "広角砲", "伝説の引っ張り屋" },
            { "対ストレート○", "対変化球○" },
            { "ストレートキラー", "対変化球○" },
            { "ポーカーフェイス", "闘志" },
            { "鉄仮面", "闘魂" }
        };
        // 削除対象のグループIDに含まれないアビリティをフィルタリング
        if (nonConcurrentMap.TryGetValue(ability.Name, out var counterpart))
        {
            var targetAbility = PQAbilitys.FirstOrDefault(x => x.Name == counterpart);
            if (targetAbility != null)
            {
                ret = pqAbilityes.Where(x => targetAbility.GroupId != x.GroupId).ToList();
            }
        }
        else if (nonConcurrentMap.ContainsValue(ability.Name))
        {
            var targetAbility = pqAbilityes.FirstOrDefault(x => nonConcurrentMap.ContainsKey(x.Name) && nonConcurrentMap[x.Name] == ability.Name);
            if (targetAbility != null)
            {
                ret = pqAbilityes.Where(x => targetAbility.GroupId != x.GroupId).ToList();
            }
        }
        return ret;
    }
    public async Task<List<PQAbility>> RemovePositionSpecificAbilities(List<PQAbility> pqAbilityes) {
        // TODO: キャラのポジションで、至高とかを除外する。
        List<(string name, int pos)> excludedInfo = new List<(string, int)>() {
            ("球界の頭脳",2),
            ("キャッチャー◯",2),
            ("至高の一塁手",3),
            ("ファースト○",3),
            ("至高の二塁手",4),
            ("セカンド○",4),
            ("至高の遊撃手",5),
            ("ショート○",5),
            ("至高の三塁手",6),
            ("サード○",6),
            ("至高の外野手",7),
            ("アウトフィールダー○",7),
            ("高速レーザー", 7),
            ("レーザービーム", 7),
        };
        var excludedAbilityData = excludedInfo.Select(a => (PQAbilitys.First(x => x.Name == a.name).Id, a.pos));
        IEnumerable<PQAbility> excludedAbilitys = pqAbilityes.Where(x => !excludedAbilityData.Where(z => z.pos != PQPlayerUnit.Position).Any(z => z.Id == x.Id));
        //
        if (isSubPosition){
            excludedAbilitys = pqAbilityes.Where(x => !excludedAbilityData.Any(z => z.Id == x.Id));
        }
        return excludedAbilitys.ToList();
    }
    public async Task<List<PQEventUnit>> RemoveNotOwnEventUnit() {
        var removedUnits = EventUnits.Where(x => !notOwnedUnits.Any(i => i == x.Id));
        return removedUnits.ToList();
    }
    public async Task<List<PQAbility>> RemoveOwnedAbilities(List<PQAbility> pqAbilityes) {
        var playerUnitAbilityes = pqAbilityes.Where(g => PQPlayerUnit.Abilities.Any(a => a.Id == g.Id));
        //グループではない || 上位金特
        var removedPQAbilities = pqAbilityes.Where(x => !playerUnitAbilityes.Any(item => x.GroupId == item.GroupId && x.Rank <= item.Rank));

        return removedPQAbilities.ToList();
    }
    public async Task<List<PQAbility>> SumLowRankSatei(List<PQAbility> pqAbilityes) {
        List<PQAbility> ret = new();

        foreach (var item in pqAbilityes) {
            //下位込みで査定を計算
            var sumSatei = pqAbilityes.Where(x => x.GroupId == item.GroupId && 0 < x.Rank && x.Rank <= item.Rank).Sum(x => x.SateiMain);
            ret.Add(new PQAbility(item.Id, item.Name, item.ColorType, item.PlayerType, item.GroupId, item.Rank, sumSatei));
        }
        return ret;
    }

    public (UnitFielderStatus fLimit, UnitPitcherStatus pLimit) CalucDeckLmit(List<Deck> pqdecks) {
        UnitFielderStatus fLimit = new(0, 0, 0, 0, 0, 0, 0, 0);
        UnitPitcherStatus pLimit = new(0, 0, 0, 0);

        foreach (var deck in pqdecks)
        {
            fLimit.Meet += deck.unit.Limit.Meet;
            fLimit.Power += deck.unit.Limit.Power;
            fLimit.RunPower += deck.unit.Limit.RunPower;
            fLimit.ShoulderPower += deck.unit.Limit.ShoulderPower;
            fLimit.Fielding += deck.unit.Limit.Fielding;
            fLimit.Catching += deck.unit.Limit.Catching;

            pLimit.BallSpeed += deck.unit.Limit.BallSpeed;
            pLimit.BallControl += deck.unit.Limit.BallControl;
            pLimit.Stamina += deck.unit.Limit.Stamina;
        }
        return (fLimit, pLimit);
    }
    //上げ上げ山
    public async Task CaluculateLimitCoachMode2() {
        int maxIterations = 30;
        //一旦デッキ決める
        await CaluculateLimitCoachMode3();
        int oldScore = EvaluateDeckLmitScore(DeckLimit, DeckPitcherLimit);

        var newUnitPool = new List<PQEventUnit>(RemoveAddedUnits);
        //いい感じにする
        for (int i = 0; i < maxIterations; i++) {
            //50以下が存在しないとき、やらない
            if (DeckLimit.Meet >= 50 && DeckLimit.Power >= 50 && DeckLimit.RunPower >= 50 && DeckLimit.ShoulderPower >= 50 && DeckLimit.Fielding >= 50 && DeckLimit.Catching >= 50) {
                if (PQPlayerUnit.Position == 1) {
                    if (DeckPitcherLimit.BallControl >= 50 && DeckPitcherLimit.Stamina>= 50){
                        break;
                    }
                }
                else {
                    break;
                }
            };

            //先頭2つはいれかえない
            var replaceablDeckUnits = decks.Where(x => x.Ability == null);
            // 50以下か。抜いたときに、50以下にならない。
            replaceablDeckUnits = 
            replaceablDeckUnits
            //50未満の上限を持っていない
            .Where(x => 
                !(DeckLimit.Meet <= 50 && x.unit.Limit.Meet > 0) &&
                !(DeckLimit.Power <= 50 && x.unit.Limit.Power > 0) &&
                !(DeckLimit.RunPower <= 50 && x.unit.Limit.RunPower > 0) &&
                !(DeckLimit.ShoulderPower <= 50 && x.unit.Limit.ShoulderPower > 0) &&
                !(DeckLimit.Fielding <= 50 && x.unit.Limit.Fielding > 0) &&
                !(DeckLimit.Catching <= 50 && x.unit.Limit.Catching > 0) &&
                !(DeckPitcherLimit.BallControl <= 50 && x.unit.Limit.BallControl > 0) &&
                !(DeckPitcherLimit.Stamina <= 50 && x.unit.Limit.Stamina > 0));

            //上限が足りていないところを優先する。
            List<(int id, int status, int limit)> statusLimitIds = new() {
                    (1,InputStatus.Meet , DeckLimit.Meet),
                    (2,InputStatus.Power , DeckLimit.Power),
                    (3,InputStatus.RunPower , DeckLimit.RunPower),
                    (4,InputStatus.ShoulderPower , DeckLimit.ShoulderPower),
                    (5,InputStatus.Fielding , DeckLimit.Fielding),
                    (6,InputStatus.Catching , DeckLimit.Catching),
            };
            var targetStatus = statusLimitIds.Where(x => x.limit < 50)
                .OrderByDescending(x => x.limit)
                .FirstOrDefault();
            //Console.WriteLine(targetStatus);

            // 対象の上限が少ない順
            var oldUnit = TargetLimitByIdOrder(replaceablDeckUnits, targetStatus.id)
                // 野手上限合計が、一番低いやつ
                .ThenBy(x => x.unit.Limit.SumFielder)
                .ThenBy(x => x.unit.Limit.SumPicher)
                .FirstOrDefault();
            if (oldUnit == null)  break;

            //すでにコーチ人数分入れたUnitは除外する
            newUnitPool = newUnitPool.Where(u => decks.Where(d => d.unit.Id == u.Id).Count() < CoarchCount).ToList();

            IEnumerable<PQEventUnit> sumLimitUnits = BalancedOrder(newUnitPool, PQPlayerUnit.Position);
            var newUnit = sumLimitUnits.First();
            // デッキをコピーする
            List<Deck> copiedDecks = new List<Deck>();
            foreach (Deck item in decks) {
                var deckUnit = item;
                copiedDecks.Add(deckUnit.Copy());
            }
            var rep = copiedDecks.FirstOrDefault(x => x.Ability == null && x.unit.Id == oldUnit.unit.Id);
            if (rep != null){
                //Console.WriteLine($"入替 {oldUnit.deckNumber} check:{oldUnit.unit.Name}→ {newUnit.Name}");
                rep.unit = newUnit;
            }
            // 入れ替えデッキ
            var limits = CalucDeckLmit(copiedDecks);
            int newScore = EvaluateDeckLmitScore(limits.fLimit, limits.pLimit);
            newUnitPool = newUnitPool.Where(u => u.Id != newUnit.Id).ToList();
            // スコアが高ければ入れ替え
            if (oldScore < newScore) {
                //Console.WriteLine($"{oldScore}→{newScore}");
                //プールをリセット
                newUnitPool = new List<PQEventUnit>(RemoveAddedUnits);
                i = 0;
                //
                decks = copiedDecks;
                DeckLimit = limits.fLimit;
                DeckPitcherLimit = limits.pLimit;
                oldScore = newScore;
            }
        }
        //重複無いようにする
        List<Deck> copiedDecks2 = decks.Where(x => x.Ability != null).ToList();
        var g = decks.Where(x => x.Ability == null).GroupBy(x => x.unit.Name).OrderByDescending(x => x.Count());
        foreach (var item in g) {
            int s = 0;
            for (int k = 0; s != item.Count(); k++) {
                var item2 = item.ElementAt(s);
                if (copiedDecks2.Count(x => x.deckNumber == k) >= DECK_MAX_COUNT) {
                }
                else {
                    copiedDecks2.Add(new Deck(item2.unit, item2.Ability, k));
                    s++;
                }
            }
        }
        decks = copiedDecks2;
    }
    public int EvaluateDeckLmitScore(UnitFielderStatus flimit,UnitPitcherStatus plimit){
        int score = 0;

        score += CalucScoreByLimit(flimit.Meet);
        score += CalucScoreByLimit(flimit.Power);
        score += CalucScoreByLimit(flimit.RunPower);
        score += CalucScoreByLimit(flimit.ShoulderPower);
        score += CalucScoreByLimit(flimit.Fielding);
        score += CalucScoreByLimit(flimit.Catching);
        if (PQPlayerUnit.Position == 1) { 
            //score += CalucScore(pitcherStatus.BallSpeed);
            score += CalucScoreByLimit(plimit.BallControl, 5);
            score += CalucScoreByLimit(plimit.Stamina, 5);
        }

        return score;
    }
    int CalucScoreByStatus(int status, int multiplier = 1) {
        int ret = 0;
        return ret;
    }
    int CalucScoreByLimit(int limit, int multiplier = 1) {
        int PLUSSCORE = 11;
        int MINUSSCORE = 3;
        int ret = 0;
        if (limit <= 50)
            ret += PLUSSCORE * limit;
        else
            ret += PLUSSCORE * 50;// - (status - 50) * MINUSSCORE;
        return ret * multiplier;
    }
    //バランス上げ(貪欲(?))
    public async Task CaluculateLimitCoachMode3()
    {
        for (int i = 0; i < CoarchCount; i++)
        {
            List<Deck> deck = decks.Where(x => x.deckNumber == i).ToList();
            int addCount = deck.Count;
            //すでに入れたUnitは除外する
            for (int k = 0; addCount < DECK_MAX_COUNT; k++) {
                deck = decks.Where(x => x.deckNumber == i).ToList();
                var unitPool = RemoveAddedUnits.Where(u => !deck.Any(d => d.unit.Id == u.Id));

                //上限をこえているか
                IEnumerable<PQEventUnit> sumLimitUnits;

                sumLimitUnits = BalancedOrder(unitPool, PQPlayerUnit.Position);
                var unit = sumLimitUnits.First();
                decks.Add(new(unit, null, i));
                var limits = CalucDeckLmit(decks);
                DeckLimit = limits.fLimit;
                DeckPitcherLimit = limits.pLimit;
                addCount++;
            }
        }

    }
    IOrderedEnumerable<PQEventUnit> TargetLimitByIdOrderDesc(IEnumerable<PQEventUnit> unitPool,int id) {
        switch (id) {
            case 1:
                return unitPool.OrderByDescending(x => x.Limit.Meet);
            case 2:
                return unitPool.OrderByDescending(x => x.Limit.Power);
            case 3:
                return unitPool.OrderByDescending(x => x.Limit.RunPower);
            case 4:
                return unitPool.OrderByDescending(x => x.Limit.ShoulderPower);
            case 5:
                return unitPool.OrderByDescending(x => x.Limit.Fielding);
            case 6:
                return unitPool.OrderByDescending(x => x.Limit.Catching);
        }
        return BalancedOrder(unitPool, PQPlayerUnit.Position);
    }

    IOrderedEnumerable<Deck> TargetLimitByIdOrder(IEnumerable<Deck> deck, int id) {
        switch (id) {
            case 1:
                return deck.OrderBy(x => x.unit.Limit.Meet);
            case 2:
                return deck.OrderBy(x => x.unit.Limit.Power);
            case 3:
                return deck.OrderBy(x => x.unit.Limit.RunPower);
            case 4:
                return deck.OrderBy(x => x.unit.Limit.ShoulderPower);
            case 5:
                return deck.OrderBy(x => x.unit.Limit.Fielding);
            case 6:
                return deck.OrderBy(x => x.unit.Limit.Catching);
        }
        return deck.OrderBy(x => x);
    }
    IOrderedEnumerable<PQEventUnit> BalancedOrder(IEnumerable<PQEventUnit> unitPool, int mode)
    {
        IOrderedEnumerable<PQEventUnit> sumLimitUnits;

        //上限をこえているか
        if (mode == 1)
        {
            sumLimitUnits = unitPool
            //投手上限の合計値が多い
            .OrderByDescending(x => {
                int sum = 0;
                sum += DeckPitcherLimit.BallControl < 50 ? x.Limit.BallControl : 0;
                sum += DeckPitcherLimit.Stamina < 50 ? x.Limit.Stamina : 0;
                return sum;
            })
            //野手上限の合計値が多い
            .ThenByDescending(x => {
                int sum = 0;
                sum += DeckLimit.Meet < 50 ? x.Limit.Meet : 0;
                sum += DeckLimit.Power < 50 ? x.Limit.Power : 0;
                sum += DeckLimit.RunPower < 50 ? x.Limit.RunPower : 0;
                sum += DeckLimit.ShoulderPower < 50 ? x.Limit.ShoulderPower : 0;
                sum += DeckLimit.Fielding < 50 ? x.Limit.Fielding : 0;
                sum += DeckLimit.Catching < 50 ? x.Limit.Catching : 0;
                return sum;
            })
              .ThenByDescending(x => GetFielderMinValue(x))
              .ThenByDescending(x => GetPitcherMinValue(x));
        }
        else{
            sumLimitUnits = unitPool.OrderByDescending(x =>
            {
                int sum = 0;
                sum += DeckLimit.Meet < 50 ? x.Limit.Meet : 0;
                sum += DeckLimit.Power < 50 ? x.Limit.Power : 0;
                sum += DeckLimit.RunPower < 50 ? x.Limit.RunPower : 0;
                sum += DeckLimit.ShoulderPower < 50 ? x.Limit.ShoulderPower : 0;
                sum += DeckLimit.Fielding < 50 ? x.Limit.Fielding : 0;
                sum += DeckLimit.Catching < 50 ? x.Limit.Catching : 0;
                return sum;
            })
                  .ThenByDescending(x => GetFielderMinValue(x));
        }
        return sumLimitUnits;
    }

    int GetFielderMinValue(PQEventUnit unit) {
        var values = new[] {
                unit.Limit.Meet,
                unit.Limit.Power,
                unit.Limit.RunPower,
                unit.Limit.ShoulderPower,
                unit.Limit.Fielding,
                unit.Limit.Catching};
        return values.Min();
    }

    int GetPitcherMinValue(PQEventUnit unit) {
        var values = new[] {
                unit.Limit.BallControl,
                unit.Limit.Stamina};
        return values.Min();
    }

    int GetPitcherMaxValue(PQEventUnit unit) {
        var values = new[] {
                unit.Limit.BallControl,
                unit.Limit.Stamina};
        return values.Max();
    }
}